# -*- coding: utf-8 -*-
"""Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13yqLrJMobr5_qzXs3QYN_Dqsw0VSWzVB

**CNN Classification:**

This is it. You have seen how to define neural networks, compute loss make updates to the weights of the network and Dataloader.

according to your data type,  you deal with image, audio, video or text, you can use a standard python packages that load data into a numpy array. then you can convert this array in to **Tensor** 

Example:
* image : packages such as pillow opencv
* audio : packages such as scipy and librosa 
* text : either rawpython or cython,  sapcy 

Packages:

* torchvision
* torchvision.datasets
* torch.utils.data.Dataloader

**Training an Image Classifier**

1. loading and Normilized 
2. convolutional Network
3. Train the Network on the train Data 
4. Testing the network on Test data
"""

# loading libs and framework 
import torch 
import torchvision 
import torchvision.transforms as transforms

!git clone https://github.com/GedamuA/Dataset.git

"""**Note:** 

The Output of torchvision dataset are PILImage of range **[0,1]**, then we transform then to tensor of normilized range **[-1,1]**.
"""

transofrm = transforms.Compose([
                                transforms.ToTensor(),
                                transforms.Normalize((.5, .5, .5), (.5, .5, .5))
])

traindataset = "../content/Dataset/Train"
testdataset = "../content/Dataset/Train"

# Trainloader
trainset = torchvision.datasets.ImageFolder(root=traindataset, transform=transofrm)
trainloader = torch.utils.data.DataLoader(
    trainset, batch_size =2, shuffle=True, num_workers=2

)

print("number of  train images ==> " + str(len(trainloader)))
# Test loader
testset = torchvision.datasets.ImageFolder(root=testdataset, transform=transofrm)
testloader = torch.utils.data.DataLoader(trainset, batch_size =2, shuffle=True, num_workers=2)

print("number of test images ==> " + str(len(testloader)))

"""let us show some images"""

import matplotlib.pyplot as plt
import numpy as np 

# functions to show an image 

def imshow(img):
  img = img / 2+ 0.5 # <-- unnormilized 
  npimg = img.numpy()
  plt.imshow(np.transpose(npimg, (1, 2, 0)))
  plt.show()


# Get the image
#dataiter = iter(trainoader)
#image, label = dataiter.next()
for i,  (data) in  enumerate (trainloader):
  image, label = data
  print(image)
  print(label)

  # show the image 
  imshow(torchvision.utils.make_grid(image))

"""Define the convolutional neural network or model 

cheer up
"""

import torch.nn as nn
import torch.functional as f

class Net(nn.Module):
  def __init__(self):
    super(Net, self).__init__()
    self.conv1 = nn.Conv2d(3, 6, 5)
    self.pool = nn.MaxPool2d(2, 2)
    self.conv2 = nn.Conv2d(6, 16, 5)
    self.relu  = nn.ReLU()
    self.fc1 = nn.Linear(16*29*29, 120)
    self.fc2 = nn.Linear(120, 84)
    self.fc3 = nn.Linear(84, 10)

  def forward(self, x):
    x = self.conv1(x)
    x = self.relu(x)
    x = self.pool(x)

    x = self.conv2(x)
    x = self.relu(x)
    x = self.pool(x)

  
    x = x.view(-1, 16*29*29)
    x = self.relu(self.fc1(x))
    x = self.relu(self.fc2(x))
    x = self.relu(self.fc3(x))

    return x

model = Net()
print(model)

"""Define the loss function and optimizer"""

import torch.optim as optim

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

"""Train the network"""

for epoch in range(10):
  running_loss = 0
  model.train()
  for i, (data) in enumerate(trainloader):
    image, label = data

    # zero the parameters of Gradient 
    optimizer.zero_grad()

    # forward + weight + optimizer

    output = model(image)
    loss = criterion (output, label)
    loss.backward()
    optimizer.step()

    # statitstics 
    running_loss+=loss.item()
    if i%2==0:
      print("epoch %d loss %f" %(epoch, running_loss))

print("finished")

"""That is all, No lets evaluate our model 

Evaluation / Testing 

we have trained the network for 2 passes over the training dataset. But we need to check if the network has learnt anything at all.

We will check this by predicting the class label that the neural network outputs, and checking it against the ground-truth. If the prediction is correct,we add the sample to the list of correct predictions.
"""

correct = 0
total = 0
with torch.no_grad():
  model.eval()
  for i, (data) in enumerate(testloader):
    image, label = data
    output = model(image)
    n, prd = torch.max(output.data, 1)
    total +=label.size(0)
    correct +=(prd==label).sum().item()
    print("Acc: %f" %(correct/total))